# Test generated by RoostGPT for test Rahul-pythn-test using AI Type Azure Open AI and AI Model roost-gpt4-32k

"""
1. Scenario: Test with a year that is a common leap year
   - Description: Verify if the function 'judge_leap_year' correctly identifies a common leap year. Common leap years are those that are evenly divisible by 4 but not by 100.
   - Test Steps: Call the 'judge_leap_year' with a known common leap year, for example 2004.
   - Expected Result: The function should return "True".

2. Scenario: Test with a year that is not a leap year
   - Description: Validate whether the 'judge_leap_year' function accurately identifies a non-leap year. A year is not a leap year if it is not divisible by 4, is divisible by 100 but not by 400.
   - Test Steps: Call the 'judge_leap_year' with a known non-leap year, for example 2001.
   - Expected Result: The function should return "False".

3. Scenario: Test with a year that is a century leap year
   - Description: Verify if the 'judge_leap_year' function correctly identifies a century leap year. A leap year is a century year only when it is perfectly divisible by 400.
   - Test Steps: Call the 'judge_leap_year' with a known century leap year, for example 2000.
   - Expected Result: The function should return "True".

4. Scenario: Test with a year that is a century but not a leap year
   - Description: Validate if the 'judge_leap_year' function accurately identifies a year which is a century year but not a leap year. A leap year is a century year if it is not perfectly divisible by 400.
   - Test Steps: Call the 'judge_leap_year' with a known century year that is not a leap year, for example 1900.
   - Expected Result: The function should return "False".

5. Scenario: Test with negative year values
   - Description: Validate the 'judge_leap_year' function response when called with a negative year value.
   - Test Steps: Call the 'judge_leap_year' with a known negative value, for example -2000.
   - Expected Result: The function may return an error or result depending on the function's design for handling such values.

6. Scenario: Test with zero as the year value
   - Description: Validate the 'judge_leap_year' function response when it is called with zero as the year value.
   - Test Steps: Call the 'judge_leap_year' with a zero year value.
   - Expected Result: The function may return an error or result depending on the function's design for handling such values.
"""
import pytest
import calculate

def test_common_leap_year():
    assert calculate.judge_leap_year(2004) == True, "Test failed, 2004 is a leap year"

def test_non_leap_year():
    assert calculate.judge_leap_year(2001) == False, "Test failed, 2001 is not a leap year"

def test_century_leap_year():
    assert calculate.judge_leap_year(2000) == True, "Test failed, 2000 is a leap year"

def test_century_not_leap_year():
    assert calculate.judge_leap_year(1900) == False, "Test failed, 1900 is not a leap year"

def test_negative_year_value():
    try:
        calculate.judge_leap_year(-2000)
    except ValueError as ve:
        assert str(ve) == "Year must be >= 1", "Test failed, negative year must raise a ValueError as per function's design"

def test_year_value_zero():
    try:
        calculate.judge_leap_year(0)
    except ValueError as ve:
        assert str(ve) == "Year must be >= 1", "Test failed, year 0 must raise a ValueError as per function's design"
