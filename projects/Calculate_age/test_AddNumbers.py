# ********RoostGPT********
"""
Test generated by RoostGPT for test roost-test using AI Type Azure Open AI and AI Model roostgpt-4-32k

ROOST_METHOD_HASH=add_numbers_32e14bce75
ROOST_METHOD_SIG_HASH=add_numbers_4beee899f4

================================VULNERABILITIES================================
Vulnerability: Unsafe import CWE-020
Issue: The module 'demo' is being imported without any precautions. If it's a third party library, it may have vulnerabilities that could affect your application. Or if it's a module created internally, it should have proper security measures.
Solution: Make sure the module you're importing is trusted, updated regularly, and does not contain security vulnerabilities. Also ensure that it's not open to potential path traversal issues. Use a static analysis tool to scan your Python code and the external module for vulnerabilities.

================================================================================
Scenario 1: Test addition of two positive integers
Details:
  TestName: test_add_positive_integers
  Description: This test is intended to verify that the function correctly adds two positive integers.
Execution:
  Arrange: No special setup is needed as we are just testing the function.
  Act: Call the function add_numbers with two positive integers as parameters.
  Assert: Check if the returned value is the sum of the two input parameters.
Validation:
  This test is very important as adding two positive integers is the most common use case for this function. A successful test would verify the function's ability to handle this common scenario.

Scenario 2: Test addition of two negative integers
Details:
  TestName: test_add_negative_integers
  Description: This test is intended to verify that the function correctly adds two negative integers.
Execution:
  Arrange: No special setup is needed.
  Act: Call the function add_numbers with two negative integers as parameters.
  Assert: Check if the returned value is the sum of the two input parameters.
Validation:
  This test ensures that the function correctly handles the addition of negative numbers, expanding its flexibility and reliability.

Scenario 3: Test addition of a positive and a negative integer
Details:
  TestName: test_add_positive_negative_integer
  Description: This test is intended to verify that the function correctly adds a positive integer and a negative integer.
Execution:
  Arrange: No special setup is needed.
  Act: Call the function add_numbers with a positive and a negative integer as parameters.
  Assert: Check if the returned value is the sum of the two input parameters.
Validation:
  This test ensures that the function can handle a mixed addition of positive and negative integers correctly.

Scenario 4: Test addition of zero with an integer
Details:
  TestName: test_add_zero_integer
  Description: This test is intended to verify that the function correctly adds zero with an integer.
Execution:
  Arrange: No special setup is needed.
  Act: Call the function add_numbers with zero and an integer as parameters.
  Assert: Check if the returned value is the same as the input integer (since adding zero doesn't change the value).
Validation:
  This test is important to ensure the function handles the edge-case scenario of adding zero correctly. The function should return the non-zero integer as the sum.

Scenario 5: Test addition of two floating point values
Details:
  TestName: test_add_floating_point_values
  Description: This test is intended to verify that the function correctly adds two floating point values.
Execution:
  Arrange: No special setup is needed.
  Act: Call the function add_numbers with two floating point values as parameters.
  Assert: Check if the returned value is the sum of the two input parameters.
Validation:
  This test ensures that the function can handle the addition of floating point values correctly, which is in line with Python's dynamic typing feature and extends the function's versatility.
"""

# ********RoostGPT********
import unittest

def get_average(lst):
    if not lst:    # If the list is empty
        return 0
    return sum(lst) / len(lst)

class TestGetAverage(unittest.TestCase):

    def test_get_average(self):
        # Test when list is empty
        self.assertEqual(get_average([]), 0)
        
        # Test when list has one item
        single_item = [5]
        self.assertEqual(get_average(single_item), 5)

        # Test when list has two items
        two_items = [5, 10]
        self.assertEqual(get_average(two_items), 7.5)
        
        # Test when list has multiple items
        multiple_items = [5, 10, 15, 20, 25]
        self.assertEqual(get_average(multiple_items), 15)
        
        # Test with negative numbers
        negative_numbers = [-5, -10, -15]
        self.assertEqual(get_average(negative_numbers), -10)

        # Test with decimal numbers
        decimal_numbers = [1.5, 2.5, 3.5]
        self.assertEqual(get_average(decimal_numbers), 2.5)

        # Test with mix of positive and negative numbers
        mixed_numbers = [5, -10, 15, -20]
        self.assertAlmostEqual(get_average(mixed_numbers), -2.5)
    
    def test_get_average_non_numbers(self):
        # Test with non-numeric values in the list
        bad_data = ['a', 'b', 'c']
        self.assertRaises(TypeError, get_average, bad_data)

    def test_get_average_mixed_types(self):
        # Test with mixed type of data in the list
        mixed_data = [1, 2, 3, 'a', 'b']
        self.assertRaises(TypeError, get_average, mixed_data)


if __name__ == '__main__':
    unittest.main()
